package com.github.javydreamercsw.base.ai.mock;

import com.github.javydreamercsw.base.ai.AIService;
import java.util.List;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/** Mock AI service for testing without using real AI APIs. Enable with: ai.provider=mock */
@Service
@Slf4j
public class MockAIService implements AIService {

  @Override
  public String analyzeWrestler(Map<String, Object> wrestlerData) {
    String wrestlerName = (String) wrestlerData.get("Name");
    log.info("Mock AI analyzing wrestler: {}", wrestlerName);

    return String.format(
        "MOCK ANALYSIS for %s:\n\n"
            + "Based on the provided data, %s shows strong potential in the wrestling industry. "
            + "Key strengths include high fan engagement and solid in-ring performance metrics. "
            + "Recommendations: Continue building storylines around their unique character traits "
            + "and consider championship opportunities.\n\n"
            + "Note: This is a mock response for testing purposes.",
        wrestlerName, wrestlerName);
  }

  @Override
  public String predictMatch(Map<String, Object> wrestler1Data, Map<String, Object> wrestler2Data) {
    String wrestler1 = (String) wrestler1Data.get("Name");
    String wrestler2 = (String) wrestler2Data.get("Name");
    log.info("Mock AI predicting match: {} vs {}", wrestler1, wrestler2);

    return String.format(
        "MOCK MATCH PREDICTION: %s vs %s\n\n"
            + "Predicted Winner: %s (60%% probability)\n\n"
            + "Analysis: This should be a competitive match with both wrestlers bringing "
            + "unique strengths. %s's experience gives them a slight edge, but %s's "
            + "agility could be the deciding factor. Expected match quality: 4/5 stars.\n\n"
            + "Note: This is a mock prediction for testing purposes.",
        wrestler1, wrestler2, wrestler1, wrestler1, wrestler2);
  }

  @Override
  public String analyzeShow(Map<String, Object> showData, List<Map<String, Object>> matchesData) {
    String showName = (String) showData.get("Name");
    log.info("Mock AI analyzing show: {} with {} matches", showName, matchesData.size());

    return String.format(
        "MOCK SHOW ANALYSIS: %s\n\n"
            + "Overall Rating: 4.2/5 stars\n\n"
            + "The show features %d matches with good pacing and storyline progression. "
            + "Strong opening and main event, with solid mid-card matches that advance "
            + "ongoing storylines. Crowd engagement should be high throughout.\n\n"
            + "Recommendations: Consider adding more backstage segments between matches "
            + "to enhance storytelling.\n\n"
            + "Note: This is a mock analysis for testing purposes.",
        showName, matchesData.size());
  }

  @Override
  public String generateStorylineSuggestions(Map<String, Object> heatData) {
    String heatName = (String) heatData.get("Name");
    log.info("Mock AI generating storyline for: {}", heatName);

    return String.format(
        "MOCK STORYLINE SUGGESTIONS for %s:\n\n"
            + "1. Personal Rivalry Arc: Build tension through backstage confrontations\n"
            + "2. Championship Implications: Tie the feud to title opportunities\n"
            + "3. Faction Involvement: Introduce allies/enemies to complicate the story\n"
            + "4. Stipulation Matches: Escalate with special match types\n"
            + "5. Resolution: Plan a satisfying conclusion at a major event\n\n"
            + "Note: This is a mock suggestion for testing purposes.",
        heatName);
  }

  @Override
  public String analyzeFaction(
      Map<String, Object> factionData, List<Map<String, Object>> membersData) {
    String factionName = (String) factionData.get("Name");
    log.info("Mock AI analyzing faction: {} with {} members", factionName, membersData.size());

    return String.format(
        "MOCK FACTION ANALYSIS: %s\n\n"
            + "Group Dynamics: Strong cohesion with %d members\n"
            + "Leadership: Clear hierarchy and direction\n"
            + "Storyline Potential: High - multiple angles available\n\n"
            + "Recommendations: Consider internal conflicts for character development "
            + "and eventual faction evolution or dissolution storylines.\n\n"
            + "Note: This is a mock analysis for testing purposes.",
        factionName, membersData.size());
  }

  @Override
  public String generateCreativeContent(String prompt, Map<String, Object> context) {
    log.info("Mock AI generating creative content for prompt: {}", prompt);

    return String.format(
        "MOCK CREATIVE CONTENT\n\n"
            + "Prompt: %s\n\n"
            + "Generated Content:\n"
            + "This is a mock creative response that would normally be generated by AI. "
            + "In a real scenario, this would be tailored creative content based on your "
            + "specific prompt and context. The content would be wrestling-appropriate "
            + "and engaging for your audience.\n\n"
            + "Note: This is a mock response for testing purposes.",
        prompt);
  }

  @Override
  public String summarizeData(Map<String, Object> data, SummaryType summaryType) {
    log.info("Mock AI summarizing data with type: {}", summaryType);

    String detail =
        switch (summaryType) {
          case BRIEF -> "Brief summary with key points only.";
          case DETAILED -> "Comprehensive overview with all important details.";
          case ANALYTICAL -> "Deep analytical summary with insights and recommendations.";
        };

    return String.format(
        "MOCK DATA SUMMARY (%s)\n\n"
            + "%s\n\n"
            + "Data contains %d fields with various wrestling-related metrics. "
            + "All values appear within normal ranges for the wrestling industry.\n\n"
            + "Note: This is a mock summary for testing purposes.",
        summaryType, detail, data.size());
  }

  @Override
  public String getProviderName() {
    return "Mock AI";
  }

  @Override
  public boolean isAvailable() {
    return true; // Always available for testing
  }
}
